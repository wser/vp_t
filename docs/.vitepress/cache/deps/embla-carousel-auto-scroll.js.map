{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/embla-carousel-auto-scroll@8.3.0_embla-carousel@8.3.0/node_modules/embla-carousel-auto-scroll/src/components/Options.ts", "../../../../node_modules/.pnpm/embla-carousel-auto-scroll@8.3.0_embla-carousel@8.3.0/node_modules/embla-carousel-auto-scroll/src/components/AutoScroll.ts"],
  "sourcesContent": ["import { CreateOptionsType } from 'embla-carousel'\n\nexport type OptionsType = CreateOptionsType<{\n  direction: 'forward' | 'backward'\n  speed: number\n  startDelay: number\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n}\n", "import { OptionsType, defaultOptions } from './Options'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType,\n  EngineType,\n  ScrollBodyType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoScroll: AutoScrollType\n  }\n\n  interface EmblaEventListType {\n    autoScrollPlay: 'autoScroll:play'\n    autoScrollStop: 'autoScroll:stop'\n  }\n}\n\nexport type AutoScrollType = CreatePluginType<\n  {\n    play: (delay?: number) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoScrollOptionsType = AutoScrollType['options']\n\nfunction AutoScroll(userOptions: AutoScrollOptionsType = {}): AutoScrollType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let timer = 0\n  let startDelay: number\n  let defaultScrollBehaviour: ScrollBodyType\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    startDelay = options.startDelay\n    destroyed = false\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody\n\n    const { eventStore } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n    const container = emblaApi.containerNode()\n\n    emblaApi.on('pointerDown', stopScroll)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startScrollOnSettle)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        stopScroll()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startScroll()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopScroll)\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startScroll)\n      }\n    }\n\n    if (options.playOnInit) startScroll()\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('pointerDown', stopScroll)\n      .off('pointerUp', startScrollOnSettle)\n      .off('slideFocusStart', stopScroll)\n      .off('settle', onSettle)\n    stopScroll()\n    destroyed = true\n    playing = false\n  }\n\n  function startScroll(): void {\n    if (destroyed || playing) return\n    if (!resume) return\n    emblaApi.emit('autoScroll:play')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    timer = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine)\n      engine.animation.start()\n    }, startDelay)\n\n    playing = true\n  }\n\n  function stopScroll(): void {\n    if (destroyed || !playing) return\n    emblaApi.emit('autoScroll:stop')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    engine.scrollBody = defaultScrollBehaviour\n    ownerWindow.clearTimeout(timer)\n    timer = 0\n\n    playing = false\n  }\n\n  function onSettle(): void {\n    if (resume) startScroll()\n    emblaApi.off('settle', onSettle)\n  }\n\n  function startScrollOnSettle(): void {\n    emblaApi.on('settle', onSettle)\n  }\n\n  function createAutoScrollBehaviour(engine: EngineType): ScrollBodyType {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: { reachedMin, reachedMax, constrain },\n      options: { loop }\n    } = engine\n    const directionSign = options.direction === 'forward' ? -1 : 1\n    const noop = (): ScrollBodyType => self\n\n    let bodyVelocity = 0\n    let scrollDirection = 0\n    let rawLocation = location.get()\n    let rawLocationPrevious = 0\n    let hasSettled = false\n\n    function seek(timeStep: number): ScrollBodyType {\n      const fixedDeltaTimeSeconds = timeStep / 1000\n      let directionDiff = 0\n\n      previousLocation.set(location)\n\n      bodyVelocity = directionSign * options.speed * 55\n      rawLocation += bodyVelocity\n      location.add(bodyVelocity * fixedDeltaTimeSeconds)\n      target.set(location)\n\n      directionDiff = rawLocation - rawLocationPrevious\n      scrollDirection = Math.sign(directionDiff)\n      rawLocationPrevious = rawLocation\n\n      const currentIndex = scrollTarget.byDistance(0, false).index\n\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get())\n        index.set(currentIndex)\n        emblaApi.emit('select')\n      }\n\n      const reachedEnd =\n        options.direction === 'forward'\n          ? reachedMin(offsetLocation.get())\n          : reachedMax(offsetLocation.get())\n\n      if (!loop && reachedEnd) {\n        hasSettled = true\n        const constrainedLocation = constrain(location.get())\n        location.set(constrainedLocation)\n        target.set(location)\n        stopScroll()\n      }\n\n      return self\n    }\n\n    const self: ScrollBodyType = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    }\n    return self\n  }\n\n  function play(startDelayOverride?: number): void {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride\n    }\n    resume = true\n    startScroll()\n  }\n\n  function stop(): void {\n    if (playing) stopScroll()\n  }\n\n  function reset(): void {\n    if (playing) {\n      stopScroll()\n      startScrollOnSettle()\n    }\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  const self: AutoScrollType = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\ndeclare namespace AutoScroll {\n  let globalOptions: AutoScrollOptionsType | undefined\n}\n\nAutoScroll.globalOptions = undefined\n\nexport default AutoScroll\n"],
  "mappings": "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",
  "names": ["defaultOptions", "direction", "speed", "startDelay", "active", "breakpoints", "playOnInit", "stopOnFocusIn", "stopOnInteraction", "stopOnMouseEnter", "rootNode", "AutoScroll", "userOptions", "options", "emblaApi", "destroyed", "playing", "resume", "timer", "defaultScrollBehaviour", "init", "emblaApiInstance", "optionsHandler", "mergeOptions", "optionsAtMedia", "optionsBase", "globalOptions", "allOptions", "scrollSnapList", "length", "internalEngine", "scrollBody", "eventStore", "emblaRoot", "root", "container", "containerNode", "on", "stopScroll", "startScrollOnSettle", "add", "startScroll", "destroy", "off", "onSettle", "emit", "engine", "ownerWindow", "setTimeout", "createAutoScrollBehaviour", "animation", "start", "clearTimeout", "location", "previousLocation", "offsetLocation", "target", "scrollTarget", "index", "indexPrevious", "limit", "reachedMin", "reachedMax", "constrain", "loop", "directionSign", "noop", "self", "bodyVelocity", "scrollDirection", "rawLocation", "get", "rawLocationPrevious", "hasSettled", "seek", "timeStep", "fixedDeltaTimeSeconds", "directionDiff", "set", "Math", "sign", "currentIndex", "byDistance", "reachedEnd", "constrainedLocation", "duration", "velocity", "settled", "useBaseFriction", "useBaseDuration", "useFriction", "useDuration", "play", "startDelayOverride", "stop", "reset", "isPlaying", "name", "undefined"]
}
